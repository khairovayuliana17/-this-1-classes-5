# УКАЗАТЕЛЬ this
Как мы уже знаем, указатели представляют собой объекты, значением которых служат __адреса других объектов__ (переменных, констант, указателей) или функций. Это мощный инструмент, позволяющий работать с памятью напрямую и создавать гибкие конструкции.
Но зачем нам думать об указателях, когда мы работаем с классами? Оказывается, в каждом методе класса неявно присутствует специальный указатель — `this`. Давайте разберёмся, как он работает и зачем нужен.

### Конфликт имён и необходимость this
Рассмотрим класс `Point`, представляющий точку на плоскости:
```cpp
class Point {

    double x, y;

public:

    Point(double x = 0.0, double y = 0.0) : x(x), y(y) {}  // Использован список инициализации

    void setX(double _x) {

        x = _x;

    }
};
```
Здесь в конструкторе мы используем __список инициализации__, который позволяет однозначно указать, что параметры `x` и `y` должны быть присвоены полям класса. Но что, если мы хотим сделать то же самое в методе `setX()`?
```cpp
void setX(double x) {

    x = x;

}
```
Тут так мы сделать не можем, так как компилятор не поймет, что из этого параметр, а что поле класса. Ну и что же нам делать?
### this — указатель на текущий объект

Для решения этой проблемы существует ключевое слово `this`. Преставь, что объект — это дом, а `this` — его точный адрес. Когда ты хочешь сделать ремонт в доме, ты как бы говоришь, что хочешь сделать его в конкретно __ЭТОМ__ доме, а не чьем-либо еще.
Так и здесь, когда мы говорим: `this->x = x;` — мы явно указываем, что хотим изменить поле `x` __ЭТОГО__ объекта, а не просто работать с локальной переменной.

*__this - указатель, существующий в каждом методе класса и указывающий на тот объект, к которому применяется метод.__*
```cpp
class Point {

    double x, y;

public:

    Point(double x = 0.0, double y = 0.0) : x(x), y(y) {}

    void setX(double x) {

        this->x = x;

    }
};
```
### Альтернатива: разыменование this
Указатель `this` можно разыменовать с помощью оператора `*`, и тогда обращение к полям и методам будет через точку `.` вместо `->`.
```cpp
class Point {

    double x, y;

public:

    Point(double x = 0.0, double y = 0.0) : x(x), y(y) {}

    void setX(double x) {

        (*this).x = x;

    }
};
```
- `*this` — сам объект (разыменованный указатель)

- `(*this).x` — обращение к полю через точку

### Возврат *this для цепочек вызовов
Указатель `this` позволяет возвращать сам объект из метода, что делает возможным __цепочки вызовов__. Это удобный и лаконичный способ последовательного применения нескольких операций к одному объекту.

``` cpp
#include <iostream>
using namespace std;
class Point {

private:
    double x, y;

public:

    Point(double x = 0, double y = 0) : x(x), y(y) {}

    // Методы, возвращающие *this для цепочек
    Point& moveX(double dx) {
        x += dx;
        return *this;
    }

    Point& moveY(double dy) {
        y += dy;
        return *this;
    }

    Point& scale(double factor) {
        x *= factor;
        y *= factor;
        return *this;
    }


    void print() const {
        cout << "(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Point p(1.0, 2.0);

    // Цепочка вызовов:
    p.moveX(3.0).moveY(-1.0).scale(2.0).print();
    // Выведет: (8, 2)
    // (1+3=4, 2-1=1) -> (4*2=8, 1*2=2)
}
```
__Важно:__
    Результат должен быть ссылкой на объект (`Point&`), иначе результатом будет не сам объект, а его копия, что приведет к неправильному вычислению.

### Указатель this: возврат по ссылке и по указателю
Когда мы работаем с указателем `this` и хотим реализовать цепочки вызовов, важно понимать разницу между возвратом объекта по ссылке (`&`) и по указателю (`*`).
1. Возврат по ссылке (`Point&`)
```cpp
class Point {
public:
    Point& moveX(double dx) {
        x += dx;
        return *this;  // Возвращаем сам объект по ссылке
    }
};
```
- Возвращает сам объект, а не его копию

- Естественный синтаксис вызовов: `obj.method1().method2()`

- Не требует дополнительных операторов при использовании

- Более безопасен, так как ссылка всегда должна указывать на существующий объект

2. Возврат по указателю (`Point*`)
```cpp
class Point {
public:
    Point* moveX(double dx) {
        x += dx;
        return this;  // Возвращаем указатель на объект
    }
};
```
- Возвращает адрес объекта

- При цепочных вызовах требует использования оператора `->`

- Может быть полезен, когда нужно явно работать с указателями

- Менее безопасен - указатель может быть `nullptr`
